import streamlit as st
import random
import string
import ipaddress
from io import BytesIO
import zipfile

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def generate_hostname(router_type, index):
    """Generate a random hostname like P-A7F3 or PE-K9D2"""
    letters = ''.join(random.choices(string.ascii_uppercase, k=1))
    digits = ''.join(random.choices(string.digits, k=1))
    letters2 = ''.join(random.choices(string.ascii_uppercase, k=1))
    digits2 = ''.join(random.choices(string.digits, k=1))
    return f"{router_type}-{letters}{digits}{letters2}{digits2}"

def allocate_loopbacks(total_routers, base_network):
    """Allocate /32 loopback addresses from base network"""
    network = ipaddress.IPv4Network(base_network)
    loopbacks = []
    for i, ip in enumerate(network.hosts()):
        if i >= total_routers:
            break
        loopbacks.append(str(ip))
    return loopbacks

def allocate_p2p_links(num_links, base_network):
    """Allocate /31 point-to-point links from base network"""
    network = ipaddress.IPv4Network(base_network)
    links = []
    hosts = list(network.hosts())
    
    for i in range(0, num_links * 2, 2):
        if i + 1 < len(hosts):
            links.append((str(hosts[i]), str(hosts[i + 1])))
    
    return links

def create_topology(num_p, num_pe):
    """Create a simple ring topology connecting all routers"""
    total = num_p + num_pe
    connections = []
    
    # Create a ring: each router connects to the next
    for i in range(total):
        next_router = (i + 1) % total
        connections.append((i, next_router))
    
    return connections

# ============================================================================
# CISCO CONFIGURATION GENERATOR
# ============================================================================

def generate_cisco_p_config(hostname, loopback_ip, interfaces_data, ospf_process="1", bgp_config=None):
    """Generate Cisco P router configuration"""
    config = f"""!
! Cisco MPLS P Router Configuration
! Generated by MPLS Config Generator
!
hostname {hostname}
!
ip cef
!
mpls label protocol ldp
!
interface Loopback0
 description MPLS Router ID
 ip address {loopback_ip} 255.255.255.255
 ip ospf {ospf_process} area 0
!
"""
    
    # Add core interfaces
    for iface_name, ip_addr, subnet_mask in interfaces_data:
        config += f"""interface {iface_name}
 description MPLS Core Link
 ip address {ip_addr} {subnet_mask}
 ip ospf {ospf_process} area 0
 ip ospf network point-to-point
 mpls ip
 no shutdown
!
"""
    
    # Add OSPF configuration
    config += f"""router ospf {ospf_process}
 router-id {loopback_ip}
 passive-interface Loopback0
!
mpls ldp router-id Loopback0 force
!
"""
    
    # Add BGP configuration if this is a Route Reflector
    if bgp_config and bgp_config.get('is_rr'):
        config += f"""router bgp {bgp_config['as_number']}
 bgp router-id {loopback_ip}
 bgp log-neighbor-changes
 no bgp default ipv4-unicast
 !
 neighbor PE-PEERS peer-group
 neighbor PE-PEERS remote-as {bgp_config['as_number']}
 neighbor PE-PEERS update-source Loopback0
 !
"""
        for pe_ip in bgp_config['pe_loopbacks']:
            config += f" neighbor {pe_ip} peer-group PE-PEERS\n"
        
        config += f""" !
 address-family vpnv4
  neighbor PE-PEERS send-community extended
  neighbor PE-PEERS route-reflector-client
"""
        for pe_ip in bgp_config['pe_loopbacks']:
            config += f"  neighbor {pe_ip} activate\n"
        
        config += " exit-address-family\n!\n"
    
    config += "end\n"
    
    return config

def generate_cisco_pe_config(hostname, loopback_ip, interfaces_data, vrf_id, ospf_process="1", bgp_config=None, add_customer_bgp=False):
    """Generate Cisco PE router configuration with VRF"""
    config = f"""!
! Cisco MPLS PE Router Configuration
! Generated by MPLS Config Generator
!
hostname {hostname}
!
ip cef
!
mpls label protocol ldp
!
vrf definition CUSTOMER_{vrf_id}
 rd {loopback_ip}:{vrf_id}
 route-target export {vrf_id}:{vrf_id}
 route-target import {vrf_id}:{vrf_id}
 !
 address-family ipv4
 exit-address-family
!
interface Loopback0
 description MPLS Router ID
 ip address {loopback_ip} 255.255.255.255
 ip ospf {ospf_process} area 0
!
"""
    
    # Add core interfaces
    for iface_name, ip_addr, subnet_mask in interfaces_data:
        config += f"""interface {iface_name}
 description MPLS Core Link
 ip address {ip_addr} {subnet_mask}
 ip ospf {ospf_process} area 0
 ip ospf network point-to-point
 mpls ip
 no shutdown
!
"""
    
    # Add example VRF interface
    config += f"""! Example VRF interface (customer-facing)
! interface GigabitEthernet0/2
!  description Customer Interface
!  vrf forwarding CUSTOMER_{vrf_id}
!  ip address 192.168.{vrf_id}.1 255.255.255.0
!  no shutdown
!
"""
    
    # Add OSPF configuration
    config += f"""router ospf {ospf_process}
 router-id {loopback_ip}
 passive-interface Loopback0
!
mpls ldp router-id Loopback0 force
!
"""
    
    # Add BGP configuration
    if bgp_config:
        config += f"""router bgp {bgp_config['as_number']}
 bgp router-id {loopback_ip}
 bgp log-neighbor-changes
 no bgp default ipv4-unicast
 !
"""
        
        # Add BGP neighbors based on topology
        if bgp_config['topology'] == 'full_mesh':
            # Full mesh with other PEs
            config += f" ! Full mesh iBGP with other PE routers\n"
            for peer_ip in bgp_config['peer_loopbacks']:
                if peer_ip != loopback_ip:
                    config += f" neighbor {peer_ip} remote-as {bgp_config['as_number']}\n"
                    config += f" neighbor {peer_ip} update-source Loopback0\n"
            
            config += " !\n address-family vpnv4\n"
            for peer_ip in bgp_config['peer_loopbacks']:
                if peer_ip != loopback_ip:
                    config += f"  neighbor {peer_ip} activate\n"
                    config += f"  neighbor {peer_ip} send-community extended\n"
            config += " exit-address-family\n"
        
        elif bgp_config['topology'] == 'route_reflector':
            # Connect to Route Reflectors
            config += f" ! iBGP to Route Reflector(s)\n"
            config += f" neighbor RR-PEERS peer-group\n"
            config += f" neighbor RR-PEERS remote-as {bgp_config['as_number']}\n"
            config += f" neighbor RR-PEERS update-source Loopback0\n"
            config += " !\n"
            
            for rr_ip in bgp_config['rr_loopbacks']:
                config += f" neighbor {rr_ip} peer-group RR-PEERS\n"
            
            config += " !\n address-family vpnv4\n"
            config += "  neighbor RR-PEERS send-community extended\n"
            for rr_ip in bgp_config['rr_loopbacks']:
                config += f"  neighbor {rr_ip} activate\n"
            config += " exit-address-family\n"
        
        # Add VRF address-family
        config += f" !\n address-family ipv4 vrf CUSTOMER_{vrf_id}\n"
        config += f"  redistribute connected\n"
        
        if add_customer_bgp:
            config += f"  ! Example customer BGP peering\n"
            config += f"  ! neighbor 192.168.{vrf_id}.2 remote-as 65{vrf_id}\n"
            config += f"  ! neighbor 192.168.{vrf_id}.2 activate\n"
        
        config += " exit-address-family\n"
        config += "!\n"
    
    config += "end\n"
    
    return config

# ============================================================================
# JUNIPER CONFIGURATION GENERATOR
# ============================================================================

def generate_juniper_p_config(hostname, loopback_ip, interfaces_data, bgp_config=None):
    """Generate Juniper P router configuration"""
    config = f"""# Juniper MPLS P Router Configuration
# Generated by MPLS Config Generator
#
set system host-name {hostname}

# Loopback interface
set interfaces lo0 unit 0 family inet address {loopback_ip}/32

"""
    
    # Add core interfaces
    for iface_name, ip_addr, subnet_mask_bits in interfaces_data:
        config += f"""# Core interface {iface_name}
set interfaces {iface_name} unit 0 description "MPLS Core Link"
set interfaces {iface_name} unit 0 family inet address {ip_addr}/{subnet_mask_bits}
set interfaces {iface_name} unit 0 family mpls

"""
    
    # Add protocols
    config += f"""# OSPF configuration
set protocols ospf area 0.0.0.0 interface lo0.0 passive
"""
    
    for iface_name, _, _ in interfaces_data:
        config += f"set protocols ospf area 0.0.0.0 interface {iface_name}.0 interface-type p2p\n"
    
    config += f"""
# MPLS and LDP configuration
set protocols mpls interface lo0.0
"""
    
    for iface_name, _, _ in interfaces_data:
        config += f"set protocols mpls interface {iface_name}.0\n"
    
    config += f"""
set protocols ldp interface lo0.0
"""
    
    for iface_name, _, _ in interfaces_data:
        config += f"set protocols ldp interface {iface_name}.0\n"
    
    config += f"""
# Router ID
set routing-options router-id {loopback_ip}
"""
    
    # Add BGP configuration if this is a Route Reflector
    if bgp_config and bgp_config.get('is_rr'):
        config += f"""
# BGP Route Reflector Configuration
set routing-options autonomous-system {bgp_config['as_number']}
set protocols bgp group PE-PEERS type internal
set protocols bgp group PE-PEERS local-address {loopback_ip}
set protocols bgp group PE-PEERS family inet-vpn unicast
set protocols bgp group PE-PEERS cluster {loopback_ip}
"""
        for pe_ip in bgp_config['pe_loopbacks']:
            config += f"set protocols bgp group PE-PEERS neighbor {pe_ip}\n"
    
    return config

def generate_juniper_pe_config(hostname, loopback_ip, interfaces_data, vrf_id, bgp_config=None, add_customer_bgp=False):
    """Generate Juniper PE router configuration with VRF"""
    config = f"""# Juniper MPLS PE Router Configuration
# Generated by MPLS Config Generator
#
set system host-name {hostname}

# Loopback interface
set interfaces lo0 unit 0 family inet address {loopback_ip}/32

"""
    
    # Add core interfaces
    for iface_name, ip_addr, subnet_mask_bits in interfaces_data:
        config += f"""# Core interface {iface_name}
set interfaces {iface_name} unit 0 description "MPLS Core Link"
set interfaces {iface_name} unit 0 family inet address {ip_addr}/{subnet_mask_bits}
set interfaces {iface_name} unit 0 family mpls

"""
    
    # Add protocols
    config += f"""# OSPF configuration
set protocols ospf area 0.0.0.0 interface lo0.0 passive
"""
    
    for iface_name, _, _ in interfaces_data:
        config += f"set protocols ospf area 0.0.0.0 interface {iface_name}.0 interface-type p2p\n"
    
    config += f"""
# MPLS and LDP configuration
set protocols mpls interface lo0.0
"""
    
    for iface_name, _, _ in interfaces_data:
        config += f"set protocols mpls interface {iface_name}.0\n"
    
    config += f"""
set protocols ldp interface lo0.0
"""
    
    for iface_name, _, _ in interfaces_data:
        config += f"set protocols ldp interface {iface_name}.0\n"
    
    config += f"""
# Router ID
set routing-options router-id {loopback_ip}
"""
    
    # Add BGP configuration
    if bgp_config:
        config += f"""
# BGP Configuration
set routing-options autonomous-system {bgp_config['as_number']}
"""
        
        if bgp_config['topology'] == 'full_mesh':
            # Full mesh with other PEs
            config += f"set protocols bgp group PE-MESH type internal\n"
            config += f"set protocols bgp group PE-MESH local-address {loopback_ip}\n"
            config += f"set protocols bgp group PE-MESH family inet-vpn unicast\n"
            
            for peer_ip in bgp_config['peer_loopbacks']:
                if peer_ip != loopback_ip:
                    config += f"set protocols bgp group PE-MESH neighbor {peer_ip}\n"
        
        elif bgp_config['topology'] == 'route_reflector':
            # Connect to Route Reflectors
            config += f"set protocols bgp group RR-CLIENTS type internal\n"
            config += f"set protocols bgp group RR-CLIENTS local-address {loopback_ip}\n"
            config += f"set protocols bgp group RR-CLIENTS family inet-vpn unicast\n"
            
            for rr_ip in bgp_config['rr_loopbacks']:
                config += f"set protocols bgp group RR-CLIENTS neighbor {rr_ip}\n"
    
    # Add VRF configuration
    config += f"""
# VRF Configuration
set routing-instances CUSTOMER_{vrf_id} instance-type vrf
set routing-instances CUSTOMER_{vrf_id} route-distinguisher {loopback_ip}:{vrf_id}
set routing-instances CUSTOMER_{vrf_id} vrf-target target:{vrf_id}:{vrf_id}
"""
    
    if bgp_config:
        config += f"set routing-instances CUSTOMER_{vrf_id} protocols bgp group CE-PEERS type external\n"
        
        if add_customer_bgp:
            config += f"# Example customer BGP peering\n"
            config += f"# set routing-instances CUSTOMER_{vrf_id} protocols bgp group CE-PEERS neighbor 192.168.{vrf_id}.2 peer-as 65{vrf_id}\n"
    
    config += f"""
# Example VRF interface (customer-facing)
# set interfaces ge-0/0/2 unit 0 description "Customer Interface"
# set interfaces ge-0/0/2 unit 0 family inet address 192.168.{vrf_id}.1/24
# set routing-instances CUSTOMER_{vrf_id} interface ge-0/0/2.0
"""
    
    return config

# ============================================================================
# STREAMLIT APPLICATION
# ============================================================================

def main():
    st.set_page_config(page_title="MPLS Config Generator", page_icon="ðŸŒ", layout="wide")
    
    st.title("ðŸŒ MPLS Configuration Generator")
    st.markdown("Generate baseline MPLS configurations for P and PE routers")
    
    # Sidebar for inputs
    st.sidebar.header("Configuration Parameters")
    
    # Vendor selection
    vendor = st.sidebar.selectbox("Select Vendor", ["Cisco", "Juniper"])
    
    # Number of routers
    st.sidebar.subheader("Router Count")
    num_p = st.sidebar.number_input("Number of P Routers", min_value=1, max_value=20, value=2)
    num_pe = st.sidebar.number_input("Number of PE Routers", min_value=1, max_value=20, value=2)
    total_routers = num_p + num_pe
    
    # Interface type
    st.sidebar.subheader("Interface Configuration")
    if vendor == "Cisco":
        default_interface = "GigabitEthernet0/0"
        interface_help = "e.g., GigabitEthernet0/0, TenGigabitEthernet0/0"
    else:
        default_interface = "ge-0/0/0"
        interface_help = "e.g., ge-0/0/0, xe-0/0/0"
    
    interface_base = st.sidebar.text_input("Interface Base Name", value=default_interface, help=interface_help)
    
    # IP addressing
    st.sidebar.subheader("IP Addressing")
    loopback_network = st.sidebar.text_input("Loopback Base Network", value="10.255.0.0/24")
    p2p_network = st.sidebar.text_input("Core P2P Network", value="10.0.0.0/24")
    
    # BGP Configuration
    st.sidebar.subheader("BGP Configuration")
    enable_bgp = st.sidebar.checkbox("Enable MP-BGP", value=True)
    bgp_as = st.sidebar.number_input("BGP AS Number", min_value=1, max_value=65535, value=65000)
    
    bgp_topology = "full_mesh"
    if enable_bgp and num_p > 0:
        bgp_topology = st.sidebar.radio(
            "BGP Topology",
            ["full_mesh", "route_reflector"],
            format_func=lambda x: "Full Mesh (PE-PE)" if x == "full_mesh" else "Route Reflector (P routers as RR)"
        )
    
    add_customer_bgp = st.sidebar.checkbox("Add Example Customer BGP", value=False, 
                                           help="Adds example CE-PE BGP configuration")
    
    # Generate button
    if st.sidebar.button("ðŸš€ Generate Configurations", type="primary"):
        with st.spinner("Generating configurations..."):
            # Allocate IP addresses
            loopbacks = allocate_loopbacks(total_routers, loopback_network)
            topology = create_topology(num_p, num_pe)
            p2p_links = allocate_p2p_links(len(topology), p2p_network)
            
            # Generate router data
            routers = []
            
            # P Routers
            for i in range(num_p):
                hostname = generate_hostname("P", i)
                routers.append({
                    'type': 'P',
                    'hostname': hostname,
                    'loopback': loopbacks[i],
                    'index': i
                })
            
            # PE Routers
            for i in range(num_pe):
                hostname = generate_hostname("PE", i)
                routers.append({
                    'type': 'PE',
                    'hostname': hostname,
                    'loopback': loopbacks[num_p + i],
                    'index': num_p + i,
                    'vrf_id': 100 + i
                })
            
            # Assign interfaces to routers
            router_interfaces = {i: [] for i in range(total_routers)}
            interface_counters = {i: 0 for i in range(total_routers)}
            
            for link_idx, (router_a, router_b) in enumerate(topology):
                if link_idx < len(p2p_links):
                    ip_a, ip_b = p2p_links[link_idx]
                    
                    # Parse interface base for increment
                    if vendor == "Cisco":
                        # Format: GigabitEthernet0/X
                        base_parts = interface_base.rsplit('/', 1)
                        iface_a = f"{base_parts[0]}/{interface_counters[router_a]}"
                        iface_b = f"{base_parts[0]}/{interface_counters[router_b]}"
                        router_interfaces[router_a].append((iface_a, ip_a, "255.255.255.254"))
                        router_interfaces[router_b].append((iface_b, ip_b, "255.255.255.254"))
                    else:
                        # Format: ge-0/0/X
                        base_parts = interface_base.rsplit('/', 1)
                        iface_a = f"{base_parts[0]}/{interface_counters[router_a]}"
                        iface_b = f"{base_parts[0]}/{interface_counters[router_b]}"
                        router_interfaces[router_a].append((iface_a, ip_a, "31"))
                        router_interfaces[router_b].append((iface_b, ip_b, "31"))
                    
                    interface_counters[router_a] += 1
                    interface_counters[router_b] += 1
            
            # Generate configurations
            configs = {}
            
            # Prepare BGP configuration data
            pe_loopbacks = [routers[num_p + i]['loopback'] for i in range(num_pe)]
            p_loopbacks = [routers[i]['loopback'] for i in range(num_p)]
            
            for router in routers:
                idx = router['index']
                interfaces = router_interfaces[idx]
                
                bgp_config = None
                if enable_bgp:
                    if router['type'] == 'P' and bgp_topology == 'route_reflector':
                        # P router as Route Reflector
                        bgp_config = {
                            'as_number': bgp_as,
                            'is_rr': True,
                            'pe_loopbacks': pe_loopbacks
                        }
                    elif router['type'] == 'PE':
                        # PE router BGP config
                        if bgp_topology == 'full_mesh':
                            bgp_config = {
                                'as_number': bgp_as,
                                'topology': 'full_mesh',
                                'peer_loopbacks': pe_loopbacks
                            }
                        else:  # route_reflector
                            bgp_config = {
                                'as_number': bgp_as,
                                'topology': 'route_reflector',
                                'rr_loopbacks': p_loopbacks
                            }
                
                if vendor == "Cisco":
                    if router['type'] == 'P':
                        config = generate_cisco_p_config(
                            router['hostname'],
                            router['loopback'],
                            interfaces,
                            bgp_config=bgp_config
                        )
                    else:
                        config = generate_cisco_pe_config(
                            router['hostname'],
                            router['loopback'],
                            interfaces,
                            router['vrf_id'],
                            bgp_config=bgp_config,
                            add_customer_bgp=add_customer_bgp
                        )
                else:  # Juniper
                    if router['type'] == 'P':
                        config = generate_juniper_p_config(
                            router['hostname'],
                            router['loopback'],
                            interfaces,
                            bgp_config=bgp_config
                        )
                    else:
                        config = generate_juniper_pe_config(
                            router['hostname'],
                            router['loopback'],
                            interfaces,
                            router['vrf_id'],
                            bgp_config=bgp_config,
                            add_customer_bgp=add_customer_bgp
                        )
                
                configs[router['hostname']] = config
            
            # Store in session state
            st.session_state['configs'] = configs
            st.session_state['vendor'] = vendor
            st.session_state['routers'] = routers
            st.session_state['topology'] = topology
            st.session_state['router_interfaces'] = router_interfaces
            st.success(f"âœ… Generated {total_routers} router configurations!")
    
    # Display configurations
    if 'configs' in st.session_state:
        configs = st.session_state['configs']
        vendor = st.session_state['vendor']
        routers = st.session_state['routers']
        topology = st.session_state['topology']
        router_interfaces = st.session_state['router_interfaces']
        
        # Display Physical Connections
        st.header("ðŸ”Œ Physical Connection Guide")
        st.markdown("**Use this guide to cable your lab equipment:**")
        
        connection_data = []
        for link_idx, (router_a_idx, router_b_idx) in enumerate(topology):
            router_a = routers[router_a_idx]
            router_b = routers[router_b_idx]
            
            # Count how many interfaces router_a has used up to this point
            interfaces_a_used = sum(1 for i, (r1, r2) in enumerate(topology[:link_idx+1]) if r1 == router_a_idx or r2 == router_a_idx)
            interfaces_b_used = sum(1 for i, (r1, r2) in enumerate(topology[:link_idx+1]) if r1 == router_b_idx or r2 == router_b_idx)
            
            # Get the correct interface for this connection
            iface_a = router_interfaces[router_a_idx][interfaces_a_used - 1][0]
            iface_b = router_interfaces[router_b_idx][interfaces_b_used - 1][0]
            ip_a = router_interfaces[router_a_idx][interfaces_a_used - 1][1]
            ip_b = router_interfaces[router_b_idx][interfaces_b_used - 1][1]
            
            connection_data.append({
                "Link #": f"Link {link_idx + 1}",
                "Router A": f"{router_a['hostname']}",
                "Interface A": iface_a,
                "IP A": ip_a,
                "âŸ·": "âŸ·",
                "Router B": f"{router_b['hostname']}",
                "Interface B": iface_b,
                "IP B": ip_b
            })
        
        # Create a clean table
        st.table(connection_data)
        
        # Export connection guide
        connection_text = "MPLS LAB PHYSICAL CONNECTION GUIDE\n"
        connection_text += "=" * 80 + "\n\n"
        for conn in connection_data:
            connection_text += f"{conn['Link #']}:\n"
            connection_text += f"  Router A: {conn['Router A']:20s} Interface: {conn['Interface A']:20s} IP: {conn['IP A']}\n"
            connection_text += f"  Router B: {conn['Router B']:20s} Interface: {conn['Interface B']:20s} IP: {conn['IP B']}\n\n"
        
        st.download_button(
            label="ðŸ“‹ Download Connection Guide",
            data=connection_text,
            file_name=f"mpls_connection_guide_{vendor.lower()}.txt",
            mime="text/plain"
        )
        
        st.markdown("---")
        
        st.header("Generated Configurations")
        
        # Configuration preview
        selected_router = st.selectbox("Select Router to Preview", list(configs.keys()))
        
        if selected_router:
            st.subheader(f"Configuration for {selected_router}")
            st.code(configs[selected_router], language="text")
        
        # Download options
        st.header("Download Configurations")
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Download as ZIP
            zip_buffer = BytesIO()
            with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                for hostname, config in configs.items():
                    filename = f"{hostname}.txt"
                    zip_file.writestr(filename, config)
            
            st.download_button(
                label="ðŸ“¦ Download All (ZIP)",
                data=zip_buffer.getvalue(),
                file_name=f"mpls_configs_{vendor.lower()}.zip",
                mime="application/zip"
            )
        
        with col2:
            # Download individual files
            st.markdown("**Download Individual Files:**")
            for hostname, config in configs.items():
                st.download_button(
                    label=f"ðŸ“„ {hostname}.txt",
                    data=config,
                    file_name=f"{hostname}.txt",
                    mime="text/plain",
                    key=hostname
                )

if __name__ == "__main__":
    main()