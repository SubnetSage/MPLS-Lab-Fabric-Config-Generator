import streamlit as st
import random
import string
import ipaddress
import json
import pandas as pd
from io import BytesIO
import zipfile
from pyvis.network import Network

PROVIDER_ASN = 65000
INTERNET_VRF_NAME = "INTERNET"
INTERNET_RT = f"{PROVIDER_ASN}:999"
INTERNET_RD = f"{PROVIDER_ASN}:999"

# =============================================================================
# 1) UTILITIES
# =============================================================================

def generate_hostname(router_type, index):
    letters = ''.join(random.choices(string.ascii_uppercase, k=2))
    digits = ''.join(random.choices(string.digits, k=2))
    return f"{router_type}-{letters}{digits}"

def allocate_loopbacks(total_routers, base_network):
    net = ipaddress.IPv4Network(base_network)
    hosts = list(net.hosts())
    if total_routers > len(hosts):
        raise ValueError(f"Loopback pool {base_network} too small for {total_routers} routers.")
    return [str(hosts[i]) for i in range(total_routers)]

def allocate_p2p_links(num_links, base_network):
    net = ipaddress.IPv4Network(base_network)
    hosts = list(net.hosts())
    needed = num_links * 2
    if needed > len(hosts):
        raise ValueError(f"P2P pool {base_network} too small for {num_links} links ({needed} IPs needed).")
    return [(str(hosts[i]), str(hosts[i + 1])) for i in range(0, needed, 2)]

def carve_subnets(base, new_prefix, count):
    base_net = ipaddress.IPv4Network(base)
    subnets = list(base_net.subnets(new_prefix=new_prefix))
    if len(subnets) < count:
        raise ValueError(f"Pool {base} too small to carve {count} subnets of /{new_prefix}.")
    return [subnets[i] for i in range(count)]

def wildcard_from_netmask(netmask: str) -> str:
    parts = [int(x) for x in netmask.split(".")]
    wc = [str(255 - p) for p in parts]
    return ".".join(wc)

# =============================================================================
# 2) RESILIENT CORE TOPOLOGY (P/PE)
# =============================================================================

def create_core_topology(num_p, num_pe, mode="auto"):
    def add_edge(edges, a, b):
        if a == b:
            return
        edges.add((min(a, b), max(a, b)))

    if num_p < 2:
        return []

    if mode == "auto":
        if num_p <= 4:
            mode = "small"
        elif num_p <= 8:
            mode = "medium"
        else:
            mode = "large"

    edges = set()

    if mode == "small":
        if num_p == 2:
            add_edge(edges, 0, 1)
        else:
            for i in range(num_p):
                add_edge(edges, i, (i + 1) % num_p)
        if num_p >= 4:
            for i in range(num_p):
                add_edge(edges, i, (i + 2) % num_p)

    elif mode == "medium":
        hub_a, hub_b = 0, 1
        add_edge(edges, hub_a, hub_b)
        non_hubs = [p for p in range(num_p) if p not in (hub_a, hub_b)]

        if len(non_hubs) >= 3:
            for i in range(len(non_hubs)):
                add_edge(edges, non_hubs[i], non_hubs[(i + 1) % len(non_hubs)])

        for p in non_hubs:
            add_edge(edges, p, hub_a)
            add_edge(edges, p, hub_b)

        if len(non_hubs) >= 5:
            for i in range(0, len(non_hubs), 2):
                add_edge(edges, non_hubs[i], non_hubs[(i + 2) % len(non_hubs)])

    elif mode == "large":
        spine_count = max(2, num_p // 3)
        spines = list(range(spine_count))
        aggs = list(range(spine_count, num_p))

        for a in aggs:
            for s in spines:
                add_edge(edges, a, s)

        for i in range(len(spines)):
            add_edge(edges, spines[i], spines[(i + 1) % len(spines)])
        if len(spines) >= 4:
            for i in range(len(spines)):
                add_edge(edges, spines[i], spines[(i + 2) % len(spines)])

        if len(aggs) >= 3:
            for i in range(len(aggs)):
                add_edge(edges, aggs[i], aggs[(i + 1) % len(aggs)])

    # PE dual-homing into core
    for i in range(num_pe):
        pe_idx = num_p + i
        if mode in ("small", "medium"):
            p1 = i % num_p
            p2 = (i + 1) % num_p
            add_edge(edges, p1, pe_idx)
            add_edge(edges, p2, pe_idx)
        else:
            spine_count = max(2, num_p // 3)
            aggs = list(range(spine_count, num_p))
            if len(aggs) >= 2:
                a1 = aggs[i % len(aggs)]
                a2 = aggs[(i + 1) % len(aggs)]
                add_edge(edges, a1, pe_idx)
                add_edge(edges, a2, pe_idx)
            else:
                p1 = i % num_p
                p2 = (i + 1) % num_p
                add_edge(edges, p1, pe_idx)
                add_edge(edges, p2, pe_idx)

    return sorted(list(edges), key=lambda x: (x[0], x[1]))

# =============================================================================
# 3) CUSTOMERS + CE BUILDOUT
# =============================================================================

def default_customers(num_customers, base_asn=65100, default_ce=1):
    rows = []
    for i in range(1, num_customers + 1):
        rows.append({
            "Customer": f"CUST_{i}",
            "Customer_ASN": base_asn + i,
            "CE_Routers": default_ce,
            "Handoff_Type": "eBGP",          # eBGP | OSPF | Static
            "LANs_per_CE": 1,
            "Leak_Via_Internet": False       # route leak via INTERNET VRF RT-bus
        })
    return pd.DataFrame(rows)

def assign_ces(customers_df, pe_core_indices):
    ces = []
    pe_cursor = 0
    ce_global = 0

    for _, row in customers_df.iterrows():
        cust = str(row["Customer"])
        asn = int(row["Customer_ASN"])
        ce_count = int(row["CE_Routers"])
        handoff = str(row.get("Handoff_Type", "eBGP"))
        lans_per_ce = int(row.get("LANs_per_CE", 1))

        for k in range(ce_count):
            ce_global += 1
            pe_attach = pe_core_indices[pe_cursor % len(pe_core_indices)]
            pe_cursor += 1

            ces.append({
                "type": "CE",
                "customer": cust,
                "customer_asn": asn,
                "handoff_type": handoff,
                "lans_per_ce": max(1, lans_per_ce),
                "hostname": generate_hostname("CE", ce_global),
                "pe_attach_core_index": pe_attach,
                "ce_seq": k + 1,
            })
    return ces

def allocate_ce_lans_multi(ces, ce_lan_pool, lan_prefix=24):
    total_lans = sum(int(ce["lans_per_ce"]) for ce in ces)
    subnets = carve_subnets(ce_lan_pool, lan_prefix, total_lans)

    cursor = 0
    for ce in ces:
        k = int(ce["lans_per_ce"])
        ce_subs = subnets[cursor:cursor + k]
        cursor += k

        ce["lan_subnets"] = [str(s) for s in ce_subs]
        ce["lan_ips"] = [str(list(s.hosts())[0]) for s in ce_subs]
        ce["lan_masks"] = [str(s.netmask) for s in ce_subs]

    return ces

# =============================================================================
# 4) VISUAL EXPORT (PYVIS)
# =============================================================================

def generate_topology_html(nodes, connection_details):
    net = Network(height="700px", width="100%", bgcolor="#ffffff", font_color="black")

    for n in nodes:
        t = n["type"]
        if t == "P":
            color, size, shape = "#3498db", 18, "diamond"
        elif t == "PE":
            color, size, shape = "#e67e22", 14, "dot"
        elif t == "RR":
            color, size, shape = "#9b59b6", 16, "diamond"
        else:
            color, size, shape = "#2ecc71", 12, "dot"

        label = n["hostname"]
        if n.get("loopback"):
            label += f"\n{n['loopback']}"
        if t == "CE":
            label += f"\n{n.get('customer','')}"
            label += f"\n{n.get('handoff_type','')}"
        if t == "RR":
            label += "\n(OOB RR)"

        net.add_node(n["hostname"], label=label, color=color, size=size, shape=shape)

    for conn in connection_details:
        host_a = "." + conn['IP A'].split('.')[-1]
        host_b = "." + conn['IP B'].split('.')[-1]
        label_text = f"{conn['Port A']} ({host_a}) <---> ({host_b}) {conn['Port B']}"
        if conn.get("VRF"):
            label_text = f"[{conn['VRF']}] " + label_text
        if conn.get("LINK_TYPE"):
            label_text = f"{conn['LINK_TYPE']} | " + label_text

        net.add_edge(
            conn['From'], conn['To'],
            label=label_text,
            color="#95a5a6",
            font={'size': 9, 'align': 'horizontal', 'color': '#2c3e50'}
        )

    net.set_options("""
    var options = {
      "physics": {
        "barnesHut": { "gravitationalConstant": -5000, "springLength": 450 }
      }
    }
    """)
    return net.generate_html()

# =============================================================================
# 5) CONFIG GENERATORS
# =============================================================================

def gen_p_config(r, ifaces):
    lb = r["loopback"]
    hostname = r["hostname"]

    conf = f"! *** P CORE CONFIG FOR {hostname} ***\n"
    conf += f"hostname {hostname}\n!\n"
    conf += "mpls ip\nmpls label protocol ldp\nmpls ldp router-id Loopback0 force\n!\n"
    conf += f"interface Loopback0\n ip address {lb} 255.255.255.255\n ip ospf 1 area 0\n!\n"

    for iface in ifaces:
        conf += (
            f"interface {iface['name']}\n"
            f" ip address {iface['ip']} {iface['mask']}\n"
            f" ip ospf 1 area 0\n"
            f" mpls ip\n"
            f" mpls ldp interface\n"
            f" no shutdown\n!\n"
        )

    conf += f"router ospf 1\n router-id {lb}\n!\nend\n"
    return conf

def gen_rr_config(rr, ifaces, pe_loopbacks, bgp_keepalive, bgp_hold):
    lb = rr["loopback"]
    hostname = rr["hostname"]

    conf = f"! *** OOB ROUTE REFLECTOR CONFIG FOR {hostname} ***\n"
    conf += f"hostname {hostname}\n!\n"

    conf += f"interface Loopback0\n ip address {lb} 255.255.255.255\n ip ospf 1 area 0\n!\n"

    for iface in ifaces:
        conf += (
            f"interface {iface['name']}\n"
            f" ip address {iface['ip']} {iface['mask']}\n"
            f" ip ospf 1 area 0\n"
            f" no shutdown\n!\n"
        )

    conf += f"router ospf 1\n router-id {lb}\n!\n"

    conf += f"router bgp {PROVIDER_ASN}\n"
    conf += " bgp log-neighbor-changes\n"
    conf += f" timers bgp {bgp_keepalive} {bgp_hold}\n"
    conf += f" bgp router-id {lb}\n"

    for pe_lb in pe_loopbacks:
        conf += (
            f" neighbor {pe_lb} remote-as {PROVIDER_ASN}\n"
            f" neighbor {pe_lb} update-source Loopback0\n"
        )

    conf += " address-family vpnv4\n"
    for pe_lb in pe_loopbacks:
        conf += (
            f"  neighbor {pe_lb} activate\n"
            f"  neighbor {pe_lb} send-community both\n"
            f"  neighbor {pe_lb} route-reflector-client\n"
        )
    conf += " exit-address-family\n!\nend\n"
    return conf

def gen_pe_config(
    pe,
    ifaces_core,
    ifaces_access,
    customers_df,
    rr_loopback,
    pe_ce_neighbors,
    bgp_keepalive,
    bgp_hold,
    ebgp_multihop,
    add_internet_default
):
    lb = pe["loopback"]
    hostname = pe["hostname"]

    # lookup per customer
    cust_handoff = {str(r["Customer"]): str(r.get("Handoff_Type", "eBGP")) for _, r in customers_df.iterrows()}
    cust_leak = {str(r["Customer"]): bool(r.get("Leak_Via_Internet", False)) for _, r in customers_df.iterrows()}

    conf = f"! *** PE EDGE CONFIG FOR {hostname} (VRF + RR + Route Leaking) ***\n"
    conf += f"hostname {hostname}\n!\n"

    # ---- INTERNET VRF (shared leaking bus)
    conf += (
        f"vrf definition {INTERNET_VRF_NAME}\n"
        f" rd {INTERNET_RD}\n"
        f" route-target both {INTERNET_RT}\n"
        f" address-family ipv4\n"
        f" exit-address-family\n!\n"
    )

    # ---- Customer VRFs (with optional RT leaking to/from INTERNET)
    for _, row in customers_df.iterrows():
        cust = str(row["Customer"])
        cust_id = int(cust.split("_")[-1])
        cust_rt = f"{PROVIDER_ASN}:{100 + cust_id}"
        cust_rd = cust_rt

        leak = cust_leak.get(cust, False)

        conf += f"vrf definition {cust}\n"
        conf += f" rd {cust_rd}\n"
        # always keep native RT
        conf += f" route-target both {cust_rt}\n"

        # route leaking:
        # - If leak enabled, export INTERNET RT (so customer routes also carry INTERNET RT)
        # - If leak enabled, import INTERNET RT (so customer learns any routes tagged INTERNET RT)
        if leak:
            conf += f" route-target export {INTERNET_RT}\n"
            conf += f" route-target import {INTERNET_RT}\n"

        conf += (
            f" address-family ipv4\n"
            f" exit-address-family\n!\n"
        )

    # MPLS core
    conf += "mpls ip\nmpls label protocol ldp\nmpls ldp router-id Loopback0 force\n!\n"
    conf += f"interface Loopback0\n ip address {lb} 255.255.255.255\n ip ospf 1 area 0\n!\n"

    for iface in ifaces_core:
        conf += (
            f"interface {iface['name']}\n"
            f" ip address {iface['ip']} {iface['mask']}\n"
            f" ip ospf 1 area 0\n"
            f" mpls ip\n"
            f" mpls ldp interface\n"
            f" no shutdown\n!\n"
        )

    # Access interfaces
    for iface in ifaces_access:
        vrf = iface["vrf"]
        htype = cust_handoff.get(vrf, "eBGP").upper()
        conf += f"interface {iface['name']}\n"
        conf += f" vrf forwarding {vrf}\n"
        conf += f" ip address {iface['ip']} {iface['mask']}\n"
        if htype == "OSPF":
            pid = 100 + int(vrf.split("_")[-1])
            conf += f" ip ospf {pid} area 0\n"
        conf += " no shutdown\n!\n"

    # Core OSPF
    conf += f"router ospf 1\n router-id {lb}\n!\n"

    # VRF-aware OSPF processes if needed
    for _, row in customers_df.iterrows():
        cust = str(row["Customer"])
        htype = str(row.get("Handoff_Type", "eBGP")).upper()
        if htype == "OSPF":
            pid = 100 + int(cust.split("_")[-1])
            conf += (
                f"router ospf {pid} vrf {cust}\n"
                f" router-id {lb}\n"
                f"!\n"
            )

    # Optional: create an INTERNET VRF ‚Äúdefault‚Äù (lab stub) + redistribute static
    if add_internet_default:
        conf += f"ip route vrf {INTERNET_VRF_NAME} 0.0.0.0 0.0.0.0 Null0\n"

    # BGP
    conf += f"router bgp {PROVIDER_ASN}\n"
    conf += " bgp log-neighbor-changes\n"
    conf += f" timers bgp {bgp_keepalive} {bgp_hold}\n"
    conf += f" bgp router-id {lb}\n"
    conf += f" neighbor {rr_loopback} remote-as {PROVIDER_ASN}\n"
    conf += f" neighbor {rr_loopback} update-source Loopback0\n"

    # Define CE neighbors only for eBGP handoff customers
    for n in pe_ce_neighbors:
        cust = n["cust"]
        htype = cust_handoff.get(cust, "eBGP").upper()
        if htype == "EBGP":
            conf += f" neighbor {n['ce_ip']} remote-as {n['cust_asn']}\n"
            if int(ebgp_multihop) > 1:
                conf += f" neighbor {n['ce_ip']} ebgp-multihop {int(ebgp_multihop)}\n"

    # vpnv4 to RR with explicit next-hop-self
    conf += " address-family vpnv4\n"
    conf += f"  neighbor {rr_loopback} activate\n"
    conf += f"  neighbor {rr_loopback} send-community both\n"
    conf += f"  neighbor {rr_loopback} next-hop-self\n"
    conf += " exit-address-family\n"

    # INTERNET VRF AF: redistribute connected/static so it can carry ‚Äúinternet-ish‚Äù routes (lab)
    conf += f" address-family ipv4 vrf {INTERNET_VRF_NAME}\n"
    conf += "  redistribute connected\n"
    if add_internet_default:
        conf += "  redistribute static\n"
    conf += " exit-address-family\n"

    # Customer VRF AFs
    for _, row in customers_df.iterrows():
        cust = str(row["Customer"])
        htype = str(row.get("Handoff_Type", "eBGP")).upper()
        pid = 100 + int(cust.split("_")[-1])
        cust_neighbors = [n for n in pe_ce_neighbors if n["cust"] == cust]

        conf += f" address-family ipv4 vrf {cust}\n"
        conf += "  redistribute connected\n"

        if htype == "EBGP":
            for n in cust_neighbors:
                conf += f"  neighbor {n['ce_ip']} activate\n"
        elif htype == "OSPF":
            conf += f"  redistribute ospf {pid}\n"
        elif htype == "STATIC":
            conf += "  redistribute static\n"

        conf += " exit-address-family\n"

    # STATIC handoff: install per-LAN routes via CE IP (inside VRF)
    for _, row in customers_df.iterrows():
        cust = str(row["Customer"])
        htype = str(row.get("Handoff_Type", "eBGP")).upper()
        if htype != "STATIC":
            continue
        for n in pe_ce_neighbors:
            if n["cust"] != cust:
                continue
            for lan in n["ce_lan_subnets"]:
                lan_net = ipaddress.IPv4Network(lan)
                conf += f"ip route vrf {cust} {lan_net.network_address} {lan_net.netmask} {n['ce_ip']}\n"

    conf += "!\nend\n"
    return conf

def gen_ce_config(
    ce,
    iface_access,
    provider_pe_ip,
    bgp_keepalive,
    bgp_hold,
    ebgp_multihop
):
    hostname = ce["hostname"]
    cust_asn = int(ce["customer_asn"])
    htype = str(ce.get("handoff_type", "eBGP")).upper()

    conf = f"! *** CE CONFIG FOR {hostname} ({ce['customer']}) HANDOFF={htype} ***\n"
    conf += f"hostname {hostname}\n!\n"

    conf += (
        f"interface {iface_access['name']}\n"
        f" ip address {iface_access['ip']} {iface_access['mask']}\n"
        f" no shutdown\n!\n"
    )

    for i, (lan_ip, lan_mask) in enumerate(zip(ce["lan_ips"], ce["lan_masks"]), start=1):
        conf += (
            f"interface GigabitEthernet0/{i}\n"
            f" ip address {lan_ip} {lan_mask}\n"
            f" no shutdown\n!\n"
        )

    if htype == "EBGP":
        conf += f"router bgp {cust_asn}\n"
        conf += " bgp log-neighbor-changes\n"
        conf += f" timers bgp {bgp_keepalive} {bgp_hold}\n"
        conf += f" neighbor {provider_pe_ip} remote-as {PROVIDER_ASN}\n"
        if int(ebgp_multihop) > 1:
            conf += f" neighbor {provider_pe_ip} ebgp-multihop {int(ebgp_multihop)}\n"
        conf += " address-family ipv4\n"
        for lan in ce["lan_subnets"]:
            lan_net = ipaddress.IPv4Network(lan)
            conf += f"  network {lan_net.network_address} mask {lan_net.netmask}\n"
        conf += f"  neighbor {provider_pe_ip} activate\n"
        conf += " exit-address-family\n!\nend\n"
        return conf

    if htype == "OSPF":
        pid = 100 + int(ce["customer"].split("_")[-1])
        conf += f"router ospf {pid}\n"
        conf += " passive-interface default\n"
        conf += f" no passive-interface {iface_access['name']}\n"
        conf += f" network {iface_access['ip']} 0.0.0.0 area 0\n"
        for lan in ce["lan_subnets"]:
            lan_net = ipaddress.IPv4Network(lan)
            wc = wildcard_from_netmask(str(lan_net.netmask))
            conf += f" network {lan_net.network_address} {wc} area 0\n"
        conf += "!\nend\n"
        return conf

    if htype == "STATIC":
        conf += f"ip route 0.0.0.0 0.0.0.0 {provider_pe_ip}\n!\nend\n"
        return conf

    conf += "!\nend\n"
    return conf

# =============================================================================
# 6) STREAMLIT APP
# =============================================================================

def main():
    st.set_page_config(page_title="MPLS Lab Designer", layout="wide")
    st.title("üåê MPLS Lab Designer ‚Äî Resilient Core + VRFs + Route Leaking via INTERNET VRF")

    with st.sidebar:
        st.header("Core (Provider)")
        num_p = st.number_input("P Nodes", 2, 20, 6)
        num_pe = st.number_input("PE Nodes", 2, 20, 4)
        topo_mode = st.selectbox("Topology Mode", ["auto", "small", "medium", "large"], index=0)

        st.divider()
        st.header("Customers")
        num_customers = st.number_input("Customers", 1, 50, 3)
        default_ce = st.number_input("Default CE per Customer", 1, 20, 2)
        base_cust_asn = st.number_input("Customer ASN Base", 64512, 65534, 65100)

        st.divider()
        st.header("BGP Options")
        bgp_keepalive = st.number_input("BGP Keepalive (sec)", 1, 300, 30)
        bgp_hold = st.number_input("BGP Hold (sec)", 3, 900, 90)
        ebgp_multihop = st.number_input("eBGP Multihop (CE neighbors)", 1, 50, 1)

        st.divider()
        st.header("Internet VRF / Leaking")
        add_internet_default = st.checkbox("Inject default route into INTERNET VRF (Null0)", value=True)

        st.divider()
        st.header("Address Pools")
        lp_pool = st.text_input("Loopback Pool (P/PE only)", "10.255.0.0/23")
        rr_loop_pool = st.text_input("RR Loopback Pool (OOB)", "172.16.255.0/24")
        core_p2p_pool = st.text_input("Core P2P Pool (/31 endpoints)", "10.0.0.0/22")
        rr_oob_p2p_pool = st.text_input("RR OOB P2P Pool (/31 endpoints)", "172.16.0.0/24")
        access_p2p_pool = st.text_input("Access P2P Pool (PE-CE /31 endpoints)", "10.10.0.0/22")
        ce_lan_pool = st.text_input("CE LAN Pool (carved into /24s)", "192.168.0.0/16")

        generate_btn = st.button("üöÄ Build Lab", type="primary")

    # Editable customer table
    seed = (int(num_customers), int(base_cust_asn), int(default_ce))
    if "customers_df" not in st.session_state or st.session_state.get("customers_df_seed") != seed:
        st.session_state["customers_df"] = default_customers(int(num_customers), base_asn=int(base_cust_asn), default_ce=int(default_ce))
        st.session_state["customers_df_seed"] = seed

    st.subheader("üë• Customers (edit ASN / CE_Routers / Handoff_Type / LANs_per_CE / Leak_Via_Internet)")
    customers_df = st.data_editor(
        st.session_state["customers_df"],
        use_container_width=True,
        num_rows="fixed",
        column_config={
            "Handoff_Type": st.column_config.SelectboxColumn(
                "Handoff_Type",
                options=["eBGP", "OSPF", "Static"],
                help="Customer handoff from CE to PE."
            ),
            "Leak_Via_Internet": st.column_config.CheckboxColumn(
                "Leak_Via_Internet",
                help="If enabled, customer VRF imports+exports INTERNET RT for route leaking."
            )
        }
    )
    st.session_state["customers_df"] = customers_df

    if generate_btn:
        try:
            # Core inventory (P + PE)
            core_total = int(num_p) + int(num_pe)
            core_loopbacks = allocate_loopbacks(core_total, lp_pool)

            routers = []
            p_lbs, pe_lbs = [], []

            for i in range(int(num_p)):
                r = {"type": "P", "hostname": generate_hostname("P", i), "loopback": core_loopbacks[i], "index": i}
                routers.append(r)
                p_lbs.append(r["loopback"])

            for i in range(int(num_pe)):
                idx = int(num_p) + i
                r = {"type": "PE", "hostname": generate_hostname("PE", i), "loopback": core_loopbacks[idx], "index": idx}
                routers.append(r)
                pe_lbs.append(r["loopback"])

            # RR
            rr_loopback = allocate_loopbacks(1, rr_loop_pool)[0]
            rr_index = core_total
            rr = {"type": "RR", "hostname": "RR-OOB", "loopback": rr_loopback, "index": rr_index}
            routers.append(rr)

            # Core edges + RR edges
            core_edges = create_core_topology(int(num_p), int(num_pe), mode=topo_mode)
            rr_edges = []
            p_attach_a = 0
            p_attach_b = 1 if int(num_p) > 1 else 0
            rr_edges.append((p_attach_a, rr_index))
            if p_attach_b != p_attach_a:
                rr_edges.append((p_attach_b, rr_index))

            # Customers / CEs
            pe_core_indices = list(range(int(num_p), int(num_p) + int(num_pe)))
            ces = assign_ces(customers_df, pe_core_indices)
            ces = allocate_ce_lans_multi(ces, ce_lan_pool, lan_prefix=24)

            ce_start_index = len(routers)
            for i, ce in enumerate(ces):
                ce["index"] = ce_start_index + i
                routers.append(ce)

            access_edges = [(ce["pe_attach_core_index"], ce["index"]) for ce in ces]

            # Allocate IPs
            core_p2p = allocate_p2p_links(len(core_edges), core_p2p_pool)
            rr_p2p = allocate_p2p_links(len(rr_edges), rr_oob_p2p_pool)
            access_p2p = allocate_p2p_links(len(access_edges), access_p2p_pool)

            # Interfaces and connection details
            total_nodes = len(routers)
            iface_counters = {i: 0 for i in range(total_nodes)}
            router_ifaces_core = {i: [] for i in range(total_nodes)}
            router_ifaces_access = {i: [] for i in range(total_nodes)}
            conn_details = []

            def add_link(a, b, ip_a, ip_b, link_type, vrf=None, core_link=True):
                if_a = f"Gi0/{iface_counters[a]}"
                if_b = f"Gi0/{iface_counters[b]}"
                iface_counters[a] += 1
                iface_counters[b] += 1

                if core_link:
                    router_ifaces_core[a].append({"name": if_a, "ip": ip_a, "mask": "255.255.255.254"})
                    router_ifaces_core[b].append({"name": if_b, "ip": ip_b, "mask": "255.255.255.254"})
                else:
                    a_type = routers[a]["type"]
                    b_type = routers[b]["type"]
                    if a_type == "PE":
                        router_ifaces_access[a].append({"name": if_a, "ip": ip_a, "mask": "255.255.255.254", "vrf": vrf})
                        router_ifaces_access[b].append({"name": if_b, "ip": ip_b, "mask": "255.255.255.254"})
                    elif b_type == "PE":
                        router_ifaces_access[b].append({"name": if_b, "ip": ip_b, "mask": "255.255.255.254", "vrf": vrf})
                        router_ifaces_access[a].append({"name": if_a, "ip": ip_a, "mask": "255.255.255.254"})
                    else:
                        router_ifaces_access[a].append({"name": if_a, "ip": ip_a, "mask": "255.255.255.254"})
                        router_ifaces_access[b].append({"name": if_b, "ip": ip_b, "mask": "255.255.255.254"})

                conn = {
                    "From": routers[a]["hostname"],
                    "Port A": if_a,
                    "IP A": ip_a,
                    "To": routers[b]["hostname"],
                    "Port B": if_b,
                    "IP B": ip_b,
                    "LINK_TYPE": link_type
                }
                if vrf:
                    conn["VRF"] = vrf
                conn_details.append(conn)

            for i, (a, b) in enumerate(core_edges):
                ip_a, ip_b = core_p2p[i]
                add_link(a, b, ip_a, ip_b, link_type="CORE", core_link=True)

            for i, (a, b) in enumerate(rr_edges):
                ip_a, ip_b = rr_p2p[i]
                add_link(a, b, ip_a, ip_b, link_type="OOB-RR", core_link=True)

            ce_by_index = {ce["index"]: ce for ce in ces}
            for i, (a, b) in enumerate(access_edges):
                ip_a, ip_b = access_p2p[i]
                ce = ce_by_index[b] if routers[b]["type"] == "CE" else ce_by_index[a]
                add_link(a, b, ip_a, ip_b, link_type="ACCESS", vrf=ce["customer"], core_link=False)

            hostname_to_index = {r["hostname"]: idx for idx, r in enumerate(routers)}

            # CE neighbor mapping per PE
            pe_ce_neighbors = {idx: [] for idx in pe_core_indices}
            for conn in conn_details:
                if conn.get("LINK_TYPE") != "ACCESS":
                    continue

                a_idx = hostname_to_index[conn["From"]]
                b_idx = hostname_to_index[conn["To"]]
                a_type = routers[a_idx]["type"]
                b_type = routers[b_idx]["type"]

                if a_type == "PE" and b_type == "CE":
                    pe_idx = a_idx
                    ce_idx = b_idx
                    pe_ip = conn["IP A"]
                    ce_ip = conn["IP B"]
                elif b_type == "PE" and a_type == "CE":
                    pe_idx = b_idx
                    ce_idx = a_idx
                    pe_ip = conn["IP B"]
                    ce_ip = conn["IP A"]
                else:
                    continue

                ce = ce_by_index[ce_idx]
                pe_ce_neighbors[pe_idx].append({
                    "cust": ce["customer"],
                    "cust_asn": ce["customer_asn"],
                    "ce_ip": ce_ip,
                    "pe_ip": pe_ip,
                    "ce_hostname": ce["hostname"],
                    "handoff_type": ce["handoff_type"],
                    "ce_lan_subnets": ce["lan_subnets"],
                })

            # Generate configs
            configs = {}

            for r in routers:
                if r["type"] == "P":
                    configs[r["hostname"]] = gen_p_config(r, router_ifaces_core[r["index"]])

            configs[rr["hostname"]] = gen_rr_config(
                rr,
                router_ifaces_core[rr_index],
                pe_lbs,
                bgp_keepalive=int(bgp_keepalive),
                bgp_hold=int(bgp_hold)
            )

            for r in routers:
                if r["type"] == "PE":
                    configs[r["hostname"]] = gen_pe_config(
                        r,
                        ifaces_core=router_ifaces_core[r["index"]],
                        ifaces_access=router_ifaces_access[r["index"]],
                        customers_df=customers_df,
                        rr_loopback=rr_loopback,
                        pe_ce_neighbors=pe_ce_neighbors[r["index"]],
                        bgp_keepalive=int(bgp_keepalive),
                        bgp_hold=int(bgp_hold),
                        ebgp_multihop=int(ebgp_multihop),
                        add_internet_default=bool(add_internet_default)
                    )

            for ce in ces:
                ce_idx = ce["index"]
                pe_idx = ce["pe_attach_core_index"]
                n = next(x for x in pe_ce_neighbors[pe_idx] if x["ce_hostname"] == ce["hostname"])
                ce_iface = router_ifaces_access[ce_idx][0]

                configs[ce["hostname"]] = gen_ce_config(
                    ce,
                    iface_access=ce_iface,
                    provider_pe_ip=n["pe_ip"],
                    bgp_keepalive=int(bgp_keepalive),
                    bgp_hold=int(bgp_hold),
                    ebgp_multihop=int(ebgp_multihop)
                )

            st.session_state.update({
                "configs": configs,
                "routers": routers,
                "conn_details": conn_details,
                "ai_context": {
                    "inventory": routers,
                    "topology": conn_details,
                    "customers": customers_df.to_dict(orient="records"),
                    "rr": rr,
                    "internet_vrf": {"name": INTERNET_VRF_NAME, "rd": INTERNET_RD, "rt": INTERNET_RT},
                    "configs": configs,
                    "counts": {"P": int(num_p), "PE": int(num_pe), "RR": 1, "CE": len(ces)},
                    "topology_mode": topo_mode,
                    "bgp": {
                        "keepalive": int(bgp_keepalive),
                        "hold": int(bgp_hold),
                        "ebgp_multihop": int(ebgp_multihop)
                    }
                }
            })

        except Exception as e:
            st.error(f"Build failed: {e}")

    # Outputs
    if "configs" in st.session_state and st.session_state.get("conn_details"):
        c1, c2, c3 = st.columns(3)

        with c1:
            buf = BytesIO()
            with zipfile.ZipFile(buf, "w") as zf:
                for h, c in st.session_state["configs"].items():
                    zf.writestr(f"{h}.txt", c)
            st.download_button("üì¶ ZIP Configs", buf.getvalue(), "lab_configs.zip")

        with c2:
            html = generate_topology_html(st.session_state["routers"], st.session_state["conn_details"])
            st.download_button("üåê Download Diagram (HTML)", html, "topology.html", "text/html")

        with c3:
            st.download_button("ü§ñ AI JSON Context", json.dumps(st.session_state["ai_context"], indent=4), "ai_context.json")

        st.subheader("üìã Detailed Interconnect Table")
        st.table(pd.DataFrame(st.session_state["conn_details"]))

        st.divider()
        sel = st.selectbox("Preview Config", list(st.session_state["configs"].keys()))
        st.code(st.session_state["configs"][sel], language="bash")

if __name__ == "__main__":
    main()
